# -*- coding: utf-8 -*-
"""Crypto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_d7axpOO-ZXcnpi-g4XyQr2gxwBZ7eoP

# **Crypto Momentum Prediction**
"""

# 1.Predicts next day momentum or direction of momentum
# 2. uses many features and is tested on crypto market
# 3. uses hourly data but predicts daily
# 4. Action item : implement and backtest on different option enabled cryptos

# Importing necessary libraries
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt

from sklearn.preprocessing import LabelEncoder

# Define scaler as a global variable
scaler = None

# Function to preprocess the dataset
def preprocess_data(data):
    # Drop unnecessary columns if they exist
    data.drop(['datetime.1', 'Unnamed: 0'], axis=1, errors='ignore', inplace=True)

    # Encoding signals
    data['signal'] = data['signal'].map({'buy': 0, 'sell': 1, 'none': 2}).astype(int)

    # Encoding categorical variables if present
    categorical_cols = data.select_dtypes(include=['object']).columns
    for col in categorical_cols:
        le = LabelEncoder()
        data[col] = le.fit_transform(data[col])

    return data

# Function to train and test the model
def train_and_test_model(X, y):
    global scaler  # Declare scaler as global variable
    # Splitting the dataset into train and test sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Scaling features
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)

    # Training the model (Random Forest Classifier)
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train_scaled, y_train)

    # Testing the model
    accuracy = model.score(X_test_scaled, y_test)
    return model, accuracy

# Function to visualize predicted signals with enhanced styling
def visualize_signals(data, model):
    plt.figure(figsize=(14, 7))
    plt.plot(data['datetime'], data['close'], label='Close Price', color='pink', linewidth=2)

    # Predicting signals for visualization
    X_vis = data.drop(['signal'], axis=1)
    X_vis_scaled = scaler.transform(X_vis)  # Access scaler variable globally
    data['predicted_signal'] = model.predict(X_vis_scaled)

    # Highlight predicted buy signals
    buy_signals_pred = data[data['predicted_signal'] == 0]
    plt.scatter(buy_signals_pred['datetime'], buy_signals_pred['close'], label='Predicted Buy Signal', marker='^', color='green', alpha=0.8, s=100)

    # Highlight predicted sell signals
    sell_signals_pred = data[data['predicted_signal'] == 1]
    plt.scatter(sell_signals_pred['datetime'], sell_signals_pred['close'], label='Predicted Sell Signal', marker='v', color='red', alpha=0.8, s=100)

    # Adding gridlines and legend
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.legend(loc='upper left')

    # Adding title and axis labels with enhanced font style
    plt.title('Crypto Price with Predicted Buy/Sell Signals', fontsize=16, fontweight='bold')
    plt.xlabel('Date', fontsize=14, fontweight='bold')
    plt.ylabel('Crypto Close Price', fontsize=14, fontweight='bold')

    # Rotating x-axis labels for better readability
    plt.xticks(rotation=45)

    # Adding background color
    plt.gca().set_facecolor('#f7f7f7')

    # Removing top and right spines
    plt.gca().spines['top'].set_visible(False)
    plt.gca().spines['right'].set_visible(False)

    # Tight layout for better appearance
    plt.tight_layout()

    # Display the plot
    plt.show()

# Load the dataset
data = pd.read_csv('/content/data.csv')

# Preprocess the dataset
data = preprocess_data(data)

# Select features and target variable
X = data.drop(['signal'], axis=1)
y = data['signal']

# Train and test the model
model, accuracy = train_and_test_model(X, y)
print("Model Accuracy:", accuracy)

# Visualize predicted signals
visualize_signals(data, model)